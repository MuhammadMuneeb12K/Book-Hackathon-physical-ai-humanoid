"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[919],{1255:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module-2/physics-simulation","title":"2.3 Physics Simulation (Gravity, Rigid Bodies, Collisions)","description":"Having set the stage by building our Gazebo world, we now dive into the core of realistic simulation: the physics engine. For humanoid robots, accurate physics simulation is paramount, as it dictates how the robot interacts with its environment, maintains balance, and executes dynamic movements. This chapter will explore how Gazebo models fundamental physical phenomena like gravity, rigid-body dynamics, and collisions, enabling you to create truly physics-accurate simulations for your humanoid systems.","source":"@site/docs/module-2/03-physics-simulation.mdx","sourceDirName":"module-2","slug":"/module-2/physics-simulation","permalink":"/module-2/physics-simulation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"physics-simulation","title":"2.3 Physics Simulation (Gravity, Rigid Bodies, Collisions)"},"sidebar":"defaultSidebar","previous":{"title":"2.2 Building Gazebo Worlds","permalink":"/module-2/building-gazebo-worlds"},"next":{"title":"2.4 Sensor Simulation (LiDAR, Depth, IMU)","permalink":"/module-2/sensor-simulation"}}');var r=n(4848),o=n(8453);const l={id:"physics-simulation",title:"2.3 Physics Simulation (Gravity, Rigid Bodies, Collisions)"},t=void 0,c={},a=[{value:"Goal",id:"goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Tools",id:"tools",level:2},{value:"Chapter Sections",id:"chapter-sections",level:2},{value:"2.3.1 Introduction to Gazebo&#39;s Physics Engine",id:"231-introduction-to-gazebos-physics-engine",level:3},{value:"2.3.2 Configuring Global World Physics Properties",id:"232-configuring-global-world-physics-properties",level:3},{value:"2.3.3 Rigid Body Dynamics and Inertial Properties",id:"233-rigid-body-dynamics-and-inertial-properties",level:3},{value:"2.3.4 Collision Detection and Response",id:"234-collision-detection-and-response",level:3},{value:"2.3.5 Material Properties: Friction, Restitution, and Damping",id:"235-material-properties-friction-restitution-and-damping",level:3},{value:"2.3.6 Debugging Physics Issues",id:"236-debugging-physics-issues",level:3},{value:"Required Diagrams",id:"required-diagrams",level:2},{value:"Hands-on Labs",id:"hands-on-labs",level:2},{value:"Lab 2.3.1: Configure Gravity, Rigid Body, and Collision Dynamics in a Custom World",id:"lab-231-configure-gravity-rigid-body-and-collision-dynamics-in-a-custom-world",level:3},{value:"Lab 2.3.2: Applying External Forces to Objects in Gazebo",id:"lab-232-applying-external-forces-to-objects-in-gazebo",level:3},{value:"Expected Output",id:"expected-output",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Real-world Applications",id:"real-world-applications",level:2},{value:"Edge Cases",id:"edge-cases",level:2},{value:"<strong>Key Entities</strong>",id:"key-entities",level:3},{value:"<strong>References</strong>",id:"references",level:3}];function d(e){const i={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"Having set the stage by building our Gazebo world, we now dive into the core of realistic simulation: the physics engine. For humanoid robots, accurate physics simulation is paramount, as it dictates how the robot interacts with its environment, maintains balance, and executes dynamic movements. This chapter will explore how Gazebo models fundamental physical phenomena like gravity, rigid-body dynamics, and collisions, enabling you to create truly physics-accurate simulations for your humanoid systems."}),"\n",(0,r.jsx)(i.h2,{id:"goal",children:"Goal"}),"\n",(0,r.jsx)(i.p,{children:"The goal of this chapter is to teach students how to configure and utilize the physics engine within Gazebo to create physics-accurate humanoid simulation environments, focusing on gravity, rigid-body dynamics, and collision detection to realistically model robot behavior."}),"\n",(0,r.jsx)(i.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Understand the role of Gazebo's physics engine in simulating realistic robot behavior."}),"\n",(0,r.jsx)(i.li,{children:"Learn to configure global physics properties such as gravity and simulation update rates."}),"\n",(0,r.jsx)(i.li,{children:"Grasp the concept of rigid bodies and how they are defined through inertial properties in SDF/URDF."}),"\n",(0,r.jsx)(i.li,{children:"Implement accurate collision detection using simplified geometries for efficient simulation."}),"\n",(0,r.jsx)(i.li,{children:"Understand and configure friction, restitution, and damping for realistic contact interactions."}),"\n",(0,r.jsx)(i.li,{children:"Debug and troubleshoot common physics-related issues in Gazebo simulations."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"A functional Gazebo world from the previous chapter."}),"\n",(0,r.jsxs)(i.li,{children:["Familiarity with URDF/SDF concepts, especially ",(0,r.jsx)(i.code,{children:"<link>"}),", ",(0,r.jsx)(i.code,{children:"<collision>"}),", and ",(0,r.jsx)(i.code,{children:"<inertial>"})," elements."]}),"\n",(0,r.jsx)(i.li,{children:"Basic understanding of classical mechanics (mass, inertia, gravity, friction)."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Physics Engine:"})," The software component responsible for calculating the physical interactions between objects in a simulation (e.g., forces, torques, velocities, positions). Gazebo typically uses ODE, Bullet, DART, or Simbody."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Gravity:"})," The force of attraction that causes objects to fall towards the center of a celestial body. Configurable in Gazebo."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Rigid Body:"})," An object in simulation whose shape and mass distribution are assumed to be fixed, meaning it does not deform."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Inertial Properties:"})," Characteristics of a rigid body that describe its resistance to changes in motion, including mass, center of mass, and inertia tensor. Defined in the ",(0,r.jsx)(i.code,{children:"<inertial>"})," tag."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Collision:"})," The event when two or more objects come into contact, resulting in an exchange of momentum and energy."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Collision Geometry:"})," The simplified 3D shape used by the physics engine to detect contacts between objects, often different from the visual mesh. Defined in the ",(0,r.jsx)(i.code,{children:"<collision>"})," tag."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Contact Dynamics:"})," The set of rules governing how objects respond to collisions, including friction and restitution."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Friction:"})," A force that opposes motion between surfaces in contact."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Restitution (Bounciness):"})," A measure of how much kinetic energy is conserved during a collision (0 = perfectly inelastic, 1 = perfectly elastic)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Damping:"})," A force that opposes motion, often used to simulate air resistance or energy dissipation in joints."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Sim-to-Real Gap:"})," The discrepancy between simulated and real-world physics, often minimized by accurate physics configuration."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"tools",children:"Tools"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Gazebo (Ignition Fortress):"})," The simulation environment."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SDF (Simulation Description Format):"})," For defining physics properties."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"URDF:"})," For defining robot inertial properties."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Gazebo GUI:"})," For inspecting physics properties and visualizing contacts."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"chapter-sections",children:"Chapter Sections"}),"\n",(0,r.jsx)(i.h3,{id:"231-introduction-to-gazebos-physics-engine",children:"2.3.1 Introduction to Gazebo's Physics Engine"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Overview of available physics engines in Gazebo (ODE, Bullet, DART, Simbody)."}),"\n",(0,r.jsx)(i.li,{children:"The role of the physics engine in calculating motion, forces, and collisions."}),"\n",(0,r.jsx)(i.li,{children:"Balancing realism with computational performance."}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"232-configuring-global-world-physics-properties",children:"2.3.2 Configuring Global World Physics Properties"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<physics>"})," tag in SDF:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"type"}),": Selecting the physics engine."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"max_step_size"}),": Time step for physics updates."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"real_time_factor"}),": How fast simulation time progresses relative to real time."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"gravity"}),": Adjusting the gravitational vector (",(0,r.jsx)(i.code,{children:"<gravity>x y z</gravity>"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ode"}),", ",(0,r.jsx)(i.code,{children:"bullet"}),", ",(0,r.jsx)(i.code,{children:"dart"}),", ",(0,r.jsx)(i.code,{children:"simbody"})," elements for engine-specific settings (e.g., solver type, iterations)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.li,{children:"Example: Changing gravity for a lunar environment simulation."}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"233-rigid-body-dynamics-and-inertial-properties",children:"2.3.3 Rigid Body Dynamics and Inertial Properties"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"What is a Rigid Body?"})," The assumption in most physics simulations."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:["The ",(0,r.jsx)(i.code,{children:"<inertial>"})," Tag:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"mass"}),": The mass of the link (in kg)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"origin"}),": The center of mass relative to the link's origin."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"inertia"}),": The 3x3 inertia tensor (Ixx, Iyy, Izz, Ixy, Ixz, Iyz) which describes how mass is distributed around the center of mass."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.li,{children:"Importance of accurate inertial properties for realistic movement and balance."}),"\n",(0,r.jsx)(i.li,{children:"Methods for calculating inertia (CAD tools, approximations)."}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"234-collision-detection-and-response",children:"2.3.4 Collision Detection and Response"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"visual"})," vs. ",(0,r.jsx)(i.code,{children:"collision"})," geometries:"]})," Why collision geometries should be simpler."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:["Defining ",(0,r.jsx)(i.code,{children:"<collision>"})," elements:"]})," Using primitives (box, cylinder, sphere) for efficiency."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Contact Sensors:"})," How Gazebo can report contact forces and points."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Collision Filter:"})," Preventing self-collisions or collisions with specific objects."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"235-material-properties-friction-restitution-and-damping",children:"2.3.5 Material Properties: Friction, Restitution, and Damping"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<surface>"})," tag:"]})," Defining material properties for collision meshes."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<friction>"}),":"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ode/mu"})," and ",(0,r.jsx)(i.code,{children:"ode/mu2"}),": Coefficients of friction."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"patch_radius"}),", ",(0,r.jsx)(i.code,{children:"slip1"}),", ",(0,r.jsx)(i.code,{children:"slip2"}),": Advanced friction parameters."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<bounce>"}),":"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"restitution_coefficient"}),": How bouncy the surface is."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"threshold"}),": Minimum impact velocity for bounce."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Damping:"})," Adding ",(0,r.jsx)(i.code,{children:"<damping>"})," to joints or links to simulate energy loss."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"236-debugging-physics-issues",children:"2.3.6 Debugging Physics Issues"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Unstable Simulations:"})," Object jitter, explosive forces."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Penetration Errors:"})," Objects passing through each other."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Sticky Contacts:"})," Objects adhering unnaturally."]}),"\n",(0,r.jsxs)(i.li,{children:["Tips:","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Increase solver iterations."}),"\n",(0,r.jsxs)(i.li,{children:["Decrease ",(0,r.jsx)(i.code,{children:"max_step_size"}),"."]}),"\n",(0,r.jsx)(i.li,{children:"Simplify collision geometries."}),"\n",(0,r.jsx)(i.li,{children:"Check inertial properties (especially inertia tensor values)."}),"\n",(0,r.jsx)(i.li,{children:"Visualize contact points in Gazebo GUI."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"required-diagrams",children:"Required Diagrams"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Inertial Properties Diagram:"})," An illustration of a rigid body showing its center of mass and conceptual inertia tensor axes."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Collision Geometry vs. Visual Geometry:"})," A side-by-side comparison of a complex visual mesh and its simplified collision primitive."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Contact Dynamics Flowchart:"})," A flowchart showing how physics engine processes contact between two colliding bodies (detection -> force calculation -> response)."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"hands-on-labs",children:"Hands-on Labs"}),"\n",(0,r.jsx)(i.h3,{id:"lab-231-configure-gravity-rigid-body-and-collision-dynamics-in-a-custom-world",children:"Lab 2.3.1: Configure Gravity, Rigid Body, and Collision Dynamics in a Custom World"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Objective:"})," Modify ",(0,r.jsx)(i.code,{children:"simple_room.world"})," to include a dynamic object (e.g., a ball), adjust gravity, and observe collision effects by giving the ball an initial velocity."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Prerequisites:"})," Completed Lab 2.2.1 (",(0,r.jsx)(i.code,{children:"simple_room.world"})," and its launch file)."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Instructions:"})}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:["Modify ",(0,r.jsx)(i.code,{children:"simple_room.world"}),":"]})," Add a spherical model with appropriate inertial and collision properties.","\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.8">\r\n  <world name="simple_humanoid_room">\r\n    \x3c!-- ... (existing includes for Sun and Ground Plane, and wall/table models) ... --\x3e\r\n\r\n    \x3c!-- A dynamic ball --\x3e\r\n    <model name="bouncing_ball">\r\n      <pose>0 0 2 0 0 0</pose> \x3c!-- Start 2 meters in the air --\x3e\r\n      <link name="ball_link">\r\n        <inertial>\r\n          <mass>0.5</mass> \x3c!-- 0.5 kg ball --\x3e\r\n          <inertia>\r\n            <ixx>0.001</ixx> <ixy>0</ixy> <ixz>0</ixz>\r\n            <iyy>0.001</iyy> <iyz>0</iyz>\r\n            <izz>0.001</izz>\r\n          </inertia>\r\n        </inertial>\r\n        <collision name="collision">\r\n          <geometry>\r\n            <sphere>\r\n              <radius>0.1</radius>\r\n            </sphere>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                <mu>0.8</mu>\r\n                <mu2>0.8</mu2>\r\n              </ode>\r\n            </friction>\r\n            <bounce>\r\n              <restitution_coefficient>0.8</restitution_coefficient> \x3c!-- Bouncy --\x3e\r\n              <threshold>0.05</threshold>\r\n            </bounce>\r\n          </surface>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <sphere>\r\n              <radius>0.1</radius>\r\n            </sphere>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0 0.8 0 1</ambient>\r\n            <diffuse>0 0.8 0 1</diffuse>\r\n            <specular>0.1 0.1 0.1 1</specular>\r\n          </material>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Customize gravity to be lower than Earth\'s for observation --\x3e\r\n    <gravity>0 0 -5</gravity> \x3c!-- Example: approx Mars gravity --\x3e\r\n\r\n    \x3c!-- Physics settings (optional, can be default) --\x3e\r\n    <physics name="default_physics" type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1.0</real_time_factor>\r\n      <ode>\r\n        <solver>\r\n          <type>quick</type>\r\n          <iterations>50</iterations>\r\n        </solver>\r\n      </ode>\r\n    </physics>\r\n\r\n  </world>\r\n</sdf>\n'})}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:["Rebuild your ",(0,r.jsx)(i.code,{children:"my_gazebo_worlds"})," package (not strictly necessary for just world changes, but good practice):"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"cd <your_ros2_ws>\r\ncolcon build --packages-select my_gazebo_worlds\r\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Launch your custom Gazebo world:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"ros2 launch my_gazebo_worlds launch_room.launch.py\n"})}),"\n","Observe the ball falling in the modified gravity and bouncing off the ground plane and potentially the table/walls. Experiment with changing ",(0,r.jsx)(i.code,{children:"gravity"})," and ",(0,r.jsx)(i.code,{children:"restitution_coefficient"})," values in the ",(0,r.jsx)(i.code,{children:".world"})," file and re-launching to see their effects."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"lab-232-applying-external-forces-to-objects-in-gazebo",children:"Lab 2.3.2: Applying External Forces to Objects in Gazebo"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Objective:"})," Use ROS 2 commands to apply an external force to the ball in your Gazebo world, simulating an impulse."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Prerequisites:"})," Running Gazebo world from Lab 2.3.1."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Instructions:"})}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsxs)(i.strong,{children:["Ensure your ",(0,r.jsx)(i.code,{children:"simple_room.world"})," is running with the ",(0,r.jsx)(i.code,{children:"bouncing_ball"})," model."]})}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Open a new terminal and source your ROS 2 environment:"})}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"source install/setup.bash\n"})}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsxs)(i.strong,{children:["Use the ",(0,r.jsx)(i.code,{children:"ros2 service call"})," command to apply a force to the ball's link."]})," Gazebo provides services for interacting with models. We'll use the ",(0,r.jsx)(i.code,{children:"/gazebo/apply_link_wrench"})," service (available if ",(0,r.jsx)(i.code,{children:"ros_gz_sim"})," is configured correctly and connected to Gazebo)."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsxs)(i.em,{children:["Note: The exact service name and message type might depend on your ",(0,r.jsx)(i.code,{children:"ros_gz_sim"})," bridge configuration. For Ignition Gazebo, you might need to use ",(0,r.jsx)(i.code,{children:"gz topic pub /world/simple_humanoid_room/cmd_wrench ignition.msgs.Wrench"})," for direct Ignition commands if ",(0,r.jsx)(i.code,{children:"ros2 service call"})," doesn't work directly with the bridge."]})}),"\n",(0,r.jsxs)(i.p,{children:["For ",(0,r.jsx)(i.code,{children:"ros_gz_sim"}),", the service usually follows the pattern: ",(0,r.jsx)(i.code,{children:"/world/<world_name>/set_link_wrench"}),". Let's assume the bridge handles a direct ROS 2 service call to ",(0,r.jsx)(i.code,{children:"/gazebo/apply_body_wrench"})," (this can vary; check ",(0,r.jsx)(i.code,{children:"ros2 service list"})," for available services once Gazebo is running)."]}),"\n",(0,r.jsxs)(i.p,{children:["A more reliable ROS 2 way to apply wrench would be to publish to the ",(0,r.jsx)(i.code,{children:"~/wrench"})," topic of the model."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsxs)(i.strong,{children:["Using ",(0,r.jsx)(i.code,{children:"ros_gz_sim"})," topic for wrench:"]})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"In a new terminal, source ROS 2, and publish a wrench message:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:'source install/setup.bash\r\n# Identify the correct topic for the wrench. For Ignition, it\'s typically /model/bouncing_ball/link/ball_link/wrench\r\n# Check available topics: `ros2 topic list | grep wrench`\r\n# Assuming the topic name is /model/bouncing_ball/cmd_wrench, which is common for `ros_gz_sim`\r\nros2 topic pub /model/bouncing_ball/cmd_wrench ignition.msgs.Wrench "{force: {x: 10.0, y: 0.0, z: 0.0}, torque: {x: 0.0, y: 0.0, z: 0.0}, force_offset: {x: 0.0, y: 0.0, z: 0.0}, torque_offset: {x: 0.0, y: 0.0, z: 0.0}, duration: {sec: 1, nanosec: 0}}" --once\n'})}),"\n","This command applies a 10 Newton force along the X-axis for 1 second. Observe the ball's reaction in Gazebo. Experiment with different force magnitudes and directions."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"expected-output",children:"Expected Output"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"A Gazebo world where objects exhibit realistic physical behavior (falling, bouncing, sliding)."}),"\n",(0,r.jsx)(i.li,{children:"Ability to modify global gravity and observe its effects."}),"\n",(0,r.jsx)(i.li,{children:"Understanding of how inertial properties affect an object's response to forces."}),"\n",(0,r.jsx)(i.li,{children:"Capability to apply external forces to simulated objects using ROS 2 commands."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["How does defining the ",(0,r.jsx)(i.code,{children:"<inertial>"})," properties of a link in SDF/URDF contribute to the realism of a humanoid robot's simulation, particularly concerning balance and movement?"]}),"\n",(0,r.jsx)(i.li,{children:"You observe objects interpenetrating in your Gazebo simulation. What are the common causes and how would you begin to debug this issue?"}),"\n",(0,r.jsxs)(i.li,{children:["Explain the difference between ",(0,r.jsx)(i.code,{children:"mu"})," and ",(0,r.jsx)(i.code,{children:"mu2"})," in the ",(0,r.jsx)(i.code,{children:"<friction>"})," tag for ODE physics."]}),"\n",(0,r.jsxs)(i.li,{children:["Describe how the ",(0,r.jsx)(i.code,{children:"max_step_size"})," and ",(0,r.jsx)(i.code,{children:"real_time_factor"})," parameters in the ",(0,r.jsx)(i.code,{children:"<physics>"})," tag impact the accuracy and speed of a Gazebo simulation."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"real-world-applications",children:"Real-world Applications"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Humanoid Gait Development:"})," Tuning gait parameters in simulation to ensure stability and efficiency under various gravity conditions (e.g., for extraterrestrial exploration)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Robot Manipulation Tasks:"})," Simulating complex manipulation scenarios (e.g., grasping, pushing, lifting) to ensure collision-free and stable interactions with objects."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Impact Testing:"})," Evaluating a robot's robustness and damage tolerance by simulating falls or impacts in a controlled environment."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Balance Control Research:"})," Developing and testing advanced balance control algorithms for bipedal robots that can withstand external perturbations."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"edge-cases",children:"Edge Cases"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Numerical Instability:"})," Very small ",(0,r.jsx)(i.code,{children:"max_step_size"}),' or large forces can lead to numerical instability in the physics engine, causing objects to "explode" or behave erratically.']}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Missing or Incorrect Collision Geometries:"})," Objects might pass through others if their collision geometries are not defined or are too coarse."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Bad Joint Limits:"})," Poorly defined joint limits or extreme joint efforts can lead to unrealistic joint behavior or instability."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High-Frequency External Forces:"})," Applying very high-frequency forces without proper integration with the physics step size can lead to missed interactions or instability."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"key-entities",children:(0,r.jsx)(i.strong,{children:"Key Entities"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Physics Engine:"})," The computational core within Gazebo (e.g., ODE, Bullet, DART, Simbody) responsible for simulating real-world physical laws governing motion, forces, and interactions."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Gravity:"})," The force vector applied to all physical objects in the Gazebo world, defined within the ",(0,r.jsx)(i.code,{children:"<gravity>"})," tag in SDF."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Rigid Body:"})," A simplification in physics simulation where an object's form does not deform under applied forces, defined by its mass and inertial properties."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Inertial Properties:"})," Physical characteristics of a rigid body (",(0,r.jsx)(i.code,{children:"mass"}),", ",(0,r.jsx)(i.code,{children:"origin"})," of center of mass, and ",(0,r.jsx)(i.code,{children:"inertia"})," tensor) that determine its dynamic response to forces and torques."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Collision Geometry:"})," A simplified geometric shape (e.g., box, sphere, cylinder) used by the physics engine to efficiently detect contact between objects, defined in the ",(0,r.jsx)(i.code,{children:"<collision>"})," tag."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Friction:"})," The force resisting relative motion between two surfaces in contact, configured via ",(0,r.jsx)(i.code,{children:"<friction>"})," in SDF materials."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Restitution Coefficient:"})," A material property (",(0,r.jsx)(i.code,{children:"restitution_coefficient"}),') that determines the "bounciness" of collisions, ranging from 0 (no bounce) to 1 (perfectly elastic bounce).']}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Damping:"})," A force that opposes motion, often used to simulate energy dissipation in joints or environmental resistance."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"max_step_size"}),":"]})," A physics parameter in SDF that defines the maximum time step the physics engine will take for calculations, influencing simulation accuracy and stability."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"real_time_factor"}),":"]})," A physics parameter in SDF that controls the ratio of simulation time to real time; a value of 1.0 means simulation runs at real time."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"references",children:(0,r.jsx)(i.strong,{children:"References"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Erchov, S. (2018). ",(0,r.jsx)(i.em,{children:"Mastering ROS for Robotics Programming"}),". Packt Publishing. (Placeholder citation)"]}),"\n",(0,r.jsxs)(i.li,{children:["Smith, R., & Chaimowicz, L. (2013). Gazebo tutorials: Understanding physics in Gazebo. ",(0,r.jsx)(i.em,{children:"Open Robotics"}),". (Placeholder citation)"]}),"\n",(0,r.jsxs)(i.li,{children:["Toussaint, M. (2015). ",(0,r.jsx)(i.em,{children:"Robot Motion Planning"}),". Springer. (Placeholder citation)"]}),"\n",(0,r.jsxs)(i.li,{children:["Sutherland, I. E. (1963). SKETCHPAD: A man-machine graphical communication system. ",(0,r.jsx)(i.em,{children:"Massachusetts Institute of Technology, Lincoln Laboratory"}),". (Placeholder citation)"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>t});var s=n(6540);const r={},o=s.createContext(r);function l(e){const i=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(o.Provider,{value:i},e.children)}}}]);